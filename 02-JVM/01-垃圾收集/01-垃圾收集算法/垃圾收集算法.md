# 垃圾收集算法

## 概述

从如何判断对象死亡的角度，垃圾收集算法可以划分为**“引用计数式垃圾收集”（Reference Counting GC）**和**“追踪式垃圾收集”（Tracing GC）**，也被称作“直接垃圾收集”和“间接垃圾收集”。

> 现在主流的 JVM 已经没有使用引用计数的垃圾收集算法了，都在使用追踪式垃圾收集。
>
> 也就是我们所说的“引用计数法”和“可达性分析”

## 分代收集理论

现在的商业虚拟机中，基本都遵循了“分代收集理论”（Generational Collection），这个理论建立在两个假说上：

1. **大部分的对象在使用过后会快速死亡**（弱分代假说（Weak Generational Hypothesis））
2. **越多次逃过垃圾回收的对象越不会死亡**（强分代假说（Strong Generational Hypothesis））

所以根据以上两个原则，在 JVM 中将 Java 堆划分为不同的区域，根据回收对象逃过垃圾回收的次数（年龄），将对象分配到不同的区域中。对于大部分的对象，只需要关注如何保留少数不需要清理的对象（新生代（Young Generation））；对于少部分已经逃过多次垃圾回收的对象，单独放到一个区域（老年代（Old Generation）），这个区域的垃圾回收频率比较低。

这种方式兼顾了回收速度和性能开销。

> 可以每次只回收其中某一个或者某些部分的区域，产生“Minor GC”“Major GC”“Full GC”这样的回收类型的划分；
>
> 针对不同的区域安排与里面存储对象存亡特征相匹配的垃圾收集算法，产生“标记-复制算法”“标记-清除算法”“标记-整理算法”等针对性的垃圾收集算法。
>
> 这些方式全部基于分代收集理论。

### 分代回收的问题

分代收集有个明显的短板问题：跨代引用。

> 假如要现在进行一次只在新生代区域的 GC（Minor GC），但新生代中的对象是有可能被老年代所引用的，反过来也是一样。遍历整个老年代所有对象的方案会为内存回收带来负担。

为了解决这个问题，引出分代收集理论的第三条经验法则：（前两条为弱分代假说和强分代假说）

**跨代引用相对于同代引用来说仅占极少数。**（跨代引用假说（Intergenerational Reference Hypothesis））

存在互相引用关系的两个对象，是应该倾向于同时生存或者同时消亡的。如果某个新生代对象存在跨代引用，由于老年代对象难以消亡，该引用会使得新生代对象在收集时同样得以存活，进而在年龄增长之后晋升到老年代中，这时跨代引用会被消除。

> 根据跨代引用假说的理论：只需在新生代上建立一个全局的数据结构（“记忆集”，Remembered Set），这个结构把老年代划分成若干小块，标识出老年代的哪一块内存会存在跨代引用。此后当发生 Minor GC 时，只有包含了跨代引用的小块内存里的对象才会被加入到 GC Roots 进行扫描。
>
> 虽然这种方法需要在对象改变引用关系时维护记录数据的正确性，增加一些运行时的开销，但比起收集时扫描整个老年代来说仍然是划算的。

## 垃圾回收算法

### 标记-清除算法

#### 介绍

“标记-清除”（Mark-Sweep）算法是最早出现的垃圾回收算法。

算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后，统一回收掉所有被标记的对象。标记过程就是对象是否属于垃圾的判定过程。

> 后续的收集算法大多都是以标记-清除算法为基础，对其缺点进行改进而得到的。

标记-清除算法的执行过程如图所示。

![标记-清除算法的示意图](x-devonthink-item://7099A837-7FDB-4843-90CE-56FDE41F74A6)

#### 缺点

它的主要缺点有两个：

1. 如果 Java 堆中包含大量对象，而且其中大部分是需要被回收的，这时必须进行大量标记和清除的动作，效率会降低；
2. 清除之后会产生大量不连续的内存碎片，可能会导致当以后要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。

### 标记-复制算法

#### 介绍

为了解决标记-清除算法面对大量可回收对象时执行效率低的问题，将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，将存活对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。

标记-复制算法适合存活量极少数的对象。因为复制会产生大量的内存开销。分配时可以不考虑内存碎片的情况。

标记-复制算法的执行过程如图所示：

![标记-复制算法的示意图](x-devonthink-item://83FA1F72-7CD6-4844-B1D6-0E8220678CEC)

现在的商用 Java 虚拟机大多都优先采用了这种收集算法去回收新生代。

#### 缺点

可用内存缩小为了原来的一半。

#### 扩展

在 1989 年，Andrew Appel 针对具备“朝生夕灭”（新生代 98% 的对象是会被回收的）特点的对象，提出了一种更优化的半区复制分代策略，称为“Appel 式回收”。

HotSpot 虚拟机的 Serial、ParNew 等新生代收集器均采用了这种策略来设计新生代的内存布局。

Appel 式回收的具体做法是把新生代分为一块较大的 Eden 空间和两块较小的 Survivor 空间，每次分配内存只使用 Eden 和其中一块 Survivor。发生垃圾搜集时，将 Eden 和 Survivor 中仍然存活的对象一次性复制到另外一块 Survivor 空间上，然后直接清理掉 Eden 和已用过的那块 Survivor 空间。

HotSpot 虚拟机默认 Eden 和 Survivor 的大小比例是 8∶1，也即每次新生代中可用内存空间为整个新生代容量的 90%（Eden 的 80%加上一个 Survivor 的 10%），只有一个 Survivor 空间，即 10%的新生代是会被“浪费”的。

98%的对象可被回收仅仅是“普通场景”下测得的数据，任何人都没有办法百分百保证每次回收都只有不多于 10%的对象存活，因此 Appel 式回收还有一个充当罕见情况的“逃生门”的安全设计，当 Survivor 空间不足以容纳一次 Minor GC 之后存活的对象时，就需要依赖其他内存区域（实际上大多就是老年代）进行分配担保（Handle Promotion）。

内存的分配担保：如果另外一块 Survivor 空间没有足够空间存放上一次新生代收集下来的存活对象，这些对象便将通过分配担保机制直接进入老年代。

### 标记-压缩算法

#### 介绍

标记-复制算法要额外浪费空间，而且在对象存活较多的情况下，复制的开销很大。不适用于在老年代进行回收。

标记整理算法，标记过程和“标记-清除算法”一致，但是在回收过程中会对对象进行整理。让所有存活的对象都向内存空间⼀端移动，然后直接清理掉边界以外的内存。

![标记-整理算法的示意图](x-devonthink-item://054A023C-82FC-4684-9F4F-A625BCA6B32D)

#### 缺点

如果移动存活对象，尤其是在⽼年代这种回收都有⼤量对象存活区域，移动过程开销极大。甚至必须暂停用户活动（STW，Stop The World）。

> 所以需要针对移动的开销大特性，对老年代的收集器的选择进行衡量。
>
> 像 HotSpot 虚拟机⾥⾯关注吞吐量的 Parallel Scavenge 收集器是基于标记-整理算法的，⽽关注延迟的 CMS 收集器则是基于标记-清除算法的。
>
> 或者，让虚拟机平时多数时间都采⽤标记-清除算法，容忍内存碎⽚，直到内存空间的碎⽚化程度已经⼤到影响对象分配时，再采⽤标记-整理算法。前⾯提到的基于标记-清除算法的 CMS 收集器⾯临空间碎⽚过多时采⽤的就是这种处理办法。